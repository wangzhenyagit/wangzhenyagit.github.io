---
layout: post
title: 敏捷开发思考
category: 方法论
tags: 敏捷开发
---

## 背景
- 互联网业务日益负载，接入传统的业务越来越多
- 一般的重构是重构出一个独立的类来放某些通用的逻辑，但是你会发现你很难给它一个业务上的含义，只能给予一个技术维度描绘的含义。如果不是直接拷贝以前的代码逻辑，新同学并不总是知道对通用逻辑的改动或获取来自该类

## 贫血症会导致失忆症
### 贫血模型
- 贫血领域对象（Anemic Domain Object）是指仅用作数据载体，而没有行为和动作的领域对象。
- 这是通常web开发中使用的方式，这种方式的优点是开发快，不用提前建模抽象模型，一个流程里面通过get和set对象属性的方式完成。但是会造成失忆症，业务逻辑复杂了，业务逻辑、状态会散落到在大量方法中，原本的代码意图会渐渐不明确，这种情况称为由贫血症引起的失忆症。
- 优点二，如果改动一个流程，为了应对可能的变化，可能并不会刻意抽象出公用的方法，而是在一个流程中重复代码，这样改动时候这个业务与其他业务独立，并不会改变其他的流程，对新人友好。相对的，会造成有部分冗余代码。而使用DDD方式，可能会考虑这个方法是不是模型中重要的行为，增加公共的行为。可能造成一个结果就是为了维护模型的完成性，大量的对模型行为进行复用，对以前行为进行修改，然后很多流程调用此流程修改复杂。通过贫血模型的方式，稍有不同的两个流程可以通过增加版本的方式实现，但在DDD方式，为了维护模型完整性，修改地方多，不够快，但长远看，模型清楚。


## 设计领域模型的一般步骤如下：

- 根据需求划分出初步的领域和限界上下文，以及上下文之间的关系

QA：主题的界限上下文？每个界限上下文都是一个微服务？
- 进一步分析每个上下文内部，识别出哪些是实体，哪些是值对象；
- 对实体、值对象进行关联和聚合，划分出聚合的范畴和聚合根；
QA：主题中可以以product为聚合根？聚合根有行为？

- 为聚合根设计仓储，并思考实体或值对象的创建方式；
- 在工程中实践领域模型，并在实践中检验模型的合理性，倒推模型中不足的地方并重构。

## 限界上下文之间的映射关系
- 合作关系（Partnership）：两个上下文紧密合作的关系，一荣俱荣，一损俱损。
- 共享内核（Shared Kernel）：两个上下文依赖部分共享的模型。
- 客户方-供应方开发（Customer-Supplier Development）：上下文之间有组织的上下游依赖。
- 遵奉者（Conformist）：下游上下文只能盲目依赖上游上下文。
- 防腐层（Anticorruption Layer）：一个上下文通过一些适配和转换与另一个上下文交互。
- 开放主机服务（Open Host Service）：定义一种协议来让其他上下文来对本上下文进行访问。
- 发布语言（Published Language）：通常与OHS一起使用，用于定义开放主机的协议。
- 大泥球（Big Ball of Mud）：混杂在一起的上下文关系，边界不清晰。
另谋他路（SeparateWay）：两个完全没有任何联系的上下文。

## 战术建模——细化上下文
梳理清楚上下文之间的关系后，我们需要从战术层面上剖析上下文内部的组织关系。首先看下DDD中的一些定义。

### 实体
>当一个对象由其标识（而不是属性）区分时，这种对象称为实体（Entity）。  

例：最简单的，公安系统的身份信息录入，对于人的模拟，即认为是实体，因为每个人是独一无二的，且其具有唯一标识（如公安系统分发的身份证号码）。 

还有，一张票，如果是有座位号的票为实体，没有的像站票就是值对象。  

在实践上建议将属性的验证放到实体中。

### 值对象
>当一个对象用于对事务进行描述而没有唯一标识时，它被称作值对象（Value Object）。  

例：比如颜色信息，我们只需要知道{"name":"黑色"，"css":"#000000"}这样的值信息就能够满足要求了，这避免了我们对标识追踪带来的系统复杂性。  

值对象很重要，在习惯了使用数据库的数据建模后，很容易将所有对象看作实体。使用值对象，可以更好地做系统优化、精简设计。

它具有不变性、相等性和可替换性。

PS：不变性，对应开发技巧，可以把构造函数设置为空，并且不提供set方法，只通过工厂来创建。

PS：与分层模型中的VO很像，但分层模型的VO只是对外提供接口使用，而且会根据业务不同删减字段，而这个VO可以在聚合或实体内使用。

在实践中，需要保证值对象创建后就不能被修改，即不允许外部再修改其属性。在不同上下文集成时，会出现模型概念的公用，如商品模型会存在于电商的各个上下文中。在订单上下文中如果你只关注下单时商品信息快照，那么将商品对象视为值对象是很好的选择。

PS：按照是否有唯一标识的标准，这个商品应该是有的。但是在创建订单的时候，需要的只是商品的快照，并不会在调用商品的动作如上下架，需要知道的只是一堆商品的参数，从函数设计上来说只是一堆参数，如果按照面向对象和restfull就是个class，然后从DDD的角度，相对实体，就是VO了。

### 聚合根
> Aggregate(聚合）是一组相关对象的集合，作为一个整体被外界访问，聚合根（Aggregate Root）是这个聚合的根节点。

> 聚合是一个非常重要的概念，核心领域往往都需要用聚合来表达。其次，聚合在技术上有非常高的价值，可以指导详细设计。

>聚合由根实体，值对象和实体组成。

PS：聚合不一定是个场景，如抽奖，在主题的领域内，product可以为一个聚合根

### 如何创建好的聚合？

> 边界内的内容具有一致性：在一个事务中只修改一个聚合实例。如果你发现边界内很难接受强一致，不管是出于性能或产品需求的考虑，应该考虑剥离出独立的聚合，采用最终一致的方式。

> 在一个事务中只修改一个聚合实例

PS：这也要求聚合有完整的业务表达，例如在主题的领域，如商品上线，虽然需要修改很多实体，但是可以通过一个操作聚合的方式来实现。修改很多实体，本来就是不应该暴露出去的知识。

>设计小聚合：大部分的聚合都可以只包含根实体，而无需包含其他实体。即使一定要包含，可以考虑将其创建为值对象。

PS：如果一个聚合内包括了多个根实体，非常容易

> 通过唯一标识来引用其他聚合或实体：当存在对象之间的关联时，建议引用其唯一标识而非引用其整体对象。如果是外部上下文中的实体，引用其唯一标识或将需要的属性构造值对象。
如果聚合创建复杂，推荐使用工厂方法来屏蔽内部复杂的创建逻辑。
> 聚合内部多个组成对象的关系可以用来指导数据库创建，但不可避免存在一定的抗阻。如聚合中存在List<值对象>，那么在数据库中建立1:N的关联需要将值对象单独建表，此时是有id的，建议不要将该id暴露到资源库外部，对外隐蔽。

## 领域服务
一些重要的领域行为或操作，可以归类为领域服务。它既不是实体，也不是值对象的范畴。

当我们采用了微服务架构风格，一切领域逻辑的对外暴露均需要通过领域服务来进行。如原本由聚合根暴露的业务逻辑也需要依托于领域服务。

## 领域事件
领域事件是对领域内发生的活动进行的建模，并不是所有系统都需要领域事件，如果简单的领域，可以使用标准的协议方式进行交互？

## DDD工程实现
> 如代码中所示，一般的工程中包的组织方式为{com.公司名.组织架构.业务.上下文.*}，这样的组织结构能够明确的将一个上下文限定在包的内部。

```
import com.company.team.bussiness.lottery.*;//抽奖上下文
import com.company.team.bussiness.riskcontrol.*;//风控上下文
import com.company.team.bussiness.counter.*;//计数上下文
import com.company.team.bussiness.condition.*;//活动准入上下文
import com.company.team.bussiness.stock.*;//库存上下文
```

PS:这种加个bussiness的方式，主要是显示的区分的上下文。

> 对于模块内的组织结构，一般情况下我们是按照领域对象、领域服务、领域资源库、防腐层等组织方式定义的。

```
import com.company.team.bussiness.lottery.domain.valobj.*;//领域对象-值对象
import com.company.team.bussiness.lottery.domain.entity.*;//领域对象-实体
import com.company.team.bussiness.lottery.domain.aggregate.*;//领域对象-聚合根
import com.company.team.bussiness.lottery.service.*;//领域服务
import com.company.team.bussiness.lottery.repo.*;//领域资源库
import com.company.team.bussiness.lottery.facade.*;//领域防腐层
```

PS:不是所有的组织都是必须的，如防腐层，只有和外部系统进行交互的时候才需要。

### 领域对象

