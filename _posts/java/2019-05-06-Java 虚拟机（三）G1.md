---
layout: post
title: Java 虚拟机（三）G1
category: Java相关
tags: 
---

## G1
> The Garbage-First (G1) collector is a server-style garbage collector, targeted for multi-processor machines with large memories. It meets garbage collection (GC) pause time goals with a high probability, while achieving high throughput. 

为了代替cms，能够满足gc停顿时间的同时保持高可用、高吞吐。

> When performing garbage collections, G1 operates in a manner similar to the CMS collector. G1 performs a concurrent global marking phase to determine the liveness of objects throughout the heap. After the mark phase completes, G1 knows which regions are mostly empty. It collects in these regions first, which usually yields a large amount of free space. This is why this method of garbage collection is called Garbage-First. As the name suggests, G1 concentrates its collection and compaction activity on the areas of the heap that are likely to be full of reclaimable objects, that is, garbage. G1 uses a pause prediction model to meet a user-defined pause time target and selects the number of regions to collect based on the specified pause time target.

G1是的名字是garbage first，使用了pause prediction model，把需要回收的region进行个优先级的排队，然后根据模型和用户设置的时间（默认200ms）进行部分收集。

> Compact free space without lengthy GC induced pause times.

G1是能够在不延长GC时间前提下进行内存整理，与CMS比，非常厉害的一点，CMS如果想整理内存需要去刻意一次去做，无疑会延长GC时间。

> The regions identified by G1 as ripe for reclamation are garbage collected using evacuation. G1 copies objects from one or more regions of the heap to a single region on the heap, and in the process both compacts and frees up memory. This evacuation is performed in parallel on multi-processors, to decrease pause times and increase throughput. Thus, with each garbage collection, G1 continuously works to reduce fragmentation, working within the user defined pause times. This is beyond the capability of both the previous methods. CMS (Concurrent Mark Sweep ) garbage collector does not do compaction. ParallelOld garbage collection performs only whole-heap compaction, which results in considerable pause times.

**G1 copies objects from one or more regions of the heap to a single region on the heap, and in the process both compacts and frees up memory.** 这难道是region设计的最大原因？

> It is important to note that G1 is not a real-time collector. It meets the set pause time target with high probability but not absolute certainty. Based on data from previous collections, G1 does an estimate of how many regions can be collected within the user specified target time. Thus, the collector has a reasonably accurate model of the cost of collecting the regions, and it uses this model to determine which and how many regions to collect while staying within the pause time target.

通过模型预测来决定回收那些regions。

> Note: G1 has both concurrent (runs along with application threads, e.g., refinement, marking, cleanup) and parallel (multi-threaded, e.g., stop the world) phases. Full garbage collections are still single threaded, but if tuned properly your applications should avoid full GCs.

应该avoid full GCs。

## Young GC
> In summary, the following can be said about the young generation in G1:


> - The heap is a single memory space split into regions.
- Young generation memory is composed of a set of non-contiguous regions. This makes it easy to resize when needed.
- Young generation garbage collections, or young GCs, are stop the world events. All application threads are stopped for the operation.
- The young GC is done in parallel using multiple threads.
- Live objects are copied to new survivor or old generation regions.

heap是一个大整块的分成很多region，不是预先划分好的。而且由于是不连续的regions，还能动态调整大小？什么操作。其他好像没啥特殊，多线程，stw，复制算法。

## Old Generation Collection with G1（mixed GC，Old GC都有young GC过程）

### Initial Marking Phase
> Initial marking of live object is piggybacked on a young generation garbage collection.

### Concurrent Marking Phase
> If empty regions are found (as denoted by the "X"), they are removed immediately in the Remark phase. Also, "accounting" information that determines liveness is calculated.

这里，并发标记的时候就会清理很多empty region，从而释放很多空间。同时会计算一些表示region是否需要回收的信息。

### Remark Phase
> Empty regions are removed and reclaimed. Region liveness is now calculated for all regions.

并发标记未完成的，全部完成。

### Copying/Cleanup Phase
> G1 selects the regions with the lowest "liveness", those regions which can be collected the fastest. Then those regions are collected at the same time as a young GC. This is denoted in the logs as [GC pause (mixed)]. So both young and old generations are collected at the same time.

与yong GC一起mixed回收，合并一次操作。类似迭代时的，一次回收一点老年代的空间。

### 老年代回收总结
In summary, there are a few key points we can make about the G1 garbage collection on the old generation.

**Concurrent Marking Phase**  
- Liveness information is calculated concurrently while the application is running.  
- This liveness information identifies which regions will be best to reclaim during an evacuation pause.  
- There is no sweeping phase like in CMS.  
**Remark Phase**  
- Uses the Snapshot-at-the-Beginning (SATB) algorithm which is much faster then what was used with CMS.  
- Completely empty regions are reclaimed.  
**Copying/Cleanup Phase**  
- Young generation and old generation are reclaimed at the same time.  
- Old generation regions are selected based on their liveness.
 

## 参考
[oracle 官方](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html)  
[Java Hotspot G1 GC的一些关键技术](https://tech.meituan.com/2016/09/23/g1.html)
[G1 垃圾收集器介绍](https://juejin.im/entry/5af0832c51882567244deb44)