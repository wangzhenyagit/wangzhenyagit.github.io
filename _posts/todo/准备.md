### 微服务划分原则
## 优点
- 独立部署
- 小团队更专注
- 松耦合，每个微服务可以扩展
- 与语言无关
- 
## 拆分的主要原则
### AKF拆分原则
> - X 轴 ：指的是水平复制，很好理解，就是讲单体系统多运行几个实例，做个集群加负载均衡的模式。
> - Z 轴 ：是基于类似的数据分区，比如一个互联网打车应用突然或了，用户量激增，集群模式撑不住了，那就按照用户请求的地区进行数据分区，北京、上海、四川等多建几个集群。
> - Y 轴 ：就是我们所说的微服务的拆分模式，就是基于不同的业务拆分。
### 前后端分离

### 无状态服务

Restful通信风格
[](https://www.google.com/search?source=hp&ei=NZqkW9fyIOzA0PEP5sS4uAc&q=%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E5%8E%9F%E5%88%99&oq=%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86&gs_l=psy-ab.3.0.0.2641.6559.0.8633.16.13.0.0.0.0.285.1440.2-6.6.0....0...1c.1j4.64.psy-ab..10.6.1440...0i12k1.0.jQ_lx93_3KI)  
[微服务的4个设计原则和19个解决方案](https://juejin.im/entry/59b292e9f265da06633cf89a)

### CurrentHashMap设计

### 高并发高吞吐的设计
#### 过车事件
- 如果一年10亿，那么计算下来，每秒大概有30多个张，可以认为最高吞吐有每秒200
- 每秒200并发，使用kafka的特性，利用partition key为设备id，对设备进行分流，然后起多个服务，每个服务指定其中的分片
- 批量入库，对于数据库的效率比较高，代码逻辑上实现，一定周期或到达一定条数批量入库
- ES对refresh_interval可以设置时间长，用户并不关心实时性，而对响应时间有所要求

### 告警处理
- 处理时候需要单线程，需要有顺序性，因为告警的产生于消除要求顺序，平台之间告警同步是同步告警产生消除的消息而不是两张表
- kafka中可以按照告警的id或设备id进行分区
- 区分活动告警与历史告警，告警有个特点，活动告警是有上限的，且查询活动告警为主，否则从一个张大表里面取，无法全部常驻内存，而一张小的表可以常驻在内存
- 不使用代码上控制的事物，使用存储过程
- 后面批量处理，在内存中处理，处理完成后更新当前告警与历史告警表，并且更新一个递增的告警id号，下次处理根据这个id号来处理

### 分库分表
- 没有考虑分库分表，如果要分库分表，那么每个库上都会有一份完整的用户数据（用户少），方便做一些关联性的操作，一致性上由程序保证事物
- 分库分表，可以按照告警所属的的设备的id进行分片，一般会预分片，防止扩容时候重新导数据
